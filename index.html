<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Chess</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Chessboard.js CSS -->
    <link rel="stylesheet" href="https://unpkg.com/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
    <!-- Load Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
        }
        .board-container {
            width: 90vw;
            max-width: 500px;
        }
        /* Custom styling for chessboard.js to ensure responsiveness and aesthetics */
        .chessboardjs-container .square {
            border-radius: 4px; /* Soft rounded corners for squares */
        }
        .chessboardjs-container {
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            border-radius: 0.75rem; /* Large rounded corners for the whole board container */
            overflow: hidden;
            background-color: #4b5563; /* Dark background for the frame */
        }
        /* Style for the move message box */
        #status-box {
            min-height: 6rem;
        }
    </style>
</head>
<body class="selection:bg-indigo-300 selection:text-gray-900">

    <div class="w-full max-w-xl p-4 bg-white rounded-xl shadow-2xl">
        <h1 class="text-3xl font-bold text-center mb-6 text-gray-800">
            Play Chess with Gemini
        </h1>

        <!-- User Information Box (Crucial for multi-user apps) -->
        <div id="user-info" class="text-sm text-center mb-4 p-2 bg-indigo-100 border border-indigo-200 rounded-lg text-indigo-800 hidden">
            <!-- User ID will be injected here -->
        </div>

        <!-- Chess Board Container -->
        <div id="board-container" class="board-container mx-auto">
            <div id="board" style="width: 100%"></div>
        </div>

        <!-- Game Status and Controls -->
        <div class="mt-6">
            <div id="status-box" class="p-4 mb-4 rounded-lg border-2 border-gray-200 text-center text-gray-700 bg-gray-50">
                <span id="status">Make your move. You are playing White.</span>
                <div id="loading-indicator" class="mt-2 text-indigo-600 hidden">
                    <svg class="animate-spin h-5 w-5 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    Thinking...
                </div>
            </div>

            <div class="flex justify-center space-x-4">
                <button id="reset-btn" class="px-6 py-2 bg-red-500 text-white font-semibold rounded-lg shadow-md hover:bg-red-600 transition duration-150 transform hover:scale-105">
                    Reset Game
                </button>
                <button id="undo-btn" class="px-6 py-2 bg-yellow-500 text-white font-semibold rounded-lg shadow-md hover:bg-yellow-600 transition duration-150 transform hover:scale-105">
                    Undo Last Move
                </button>
            </div>
            
            <p id="fen-display" class="mt-4 text-xs text-gray-500 text-center truncate">
                FEN: r1bqkbnr/pppp1ppp/2n5/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - 1 3
            </p>
        </div>
    </div>

    <!-- Load Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- Firebase/Canvas Global Variables ---
        // Ensure these variables are available (provided by the Canvas environment)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-gemini-chess';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let db, auth, userId = null;
        let isAuthReady = false;

        if (firebaseConfig) {
            // Set debug logging for Firestore
            setLogLevel('Debug');
            
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            // 1. Authentication Setup
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    document.getElementById('user-info').textContent = `User ID: ${userId} (Share this ID to play with others)`;
                    document.getElementById('user-info').classList.remove('hidden');
                    console.log("Firebase Auth Ready. User ID:", userId);
                    isAuthReady = true;

                    // Load the game state after successful authentication
                    await loadGameState(userId);
                } else {
                    // Sign in anonymously if no token is provided, or use the token
                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            await signInAnonymously(auth);
                        }
                    } catch (error) {
                        console.error("Firebase Sign In failed:", error);
                        // Fallback to anonymous ID if sign-in fails completely
                        userId = crypto.randomUUID();
                        isAuthReady = true;
                        document.getElementById('user-info').textContent = `User ID: ${userId} (Anonymous Mode)`;
                        document.getElementById('user-info').classList.remove('hidden');
                        await loadGameState(userId);
                    }
                }
            });
        } else {
            console.error("Firebase configuration is missing.");
            // Proceed without Firebase if config is missing (will not save state)
            userId = crypto.randomUUID();
            isAuthReady = true;
        }

        // --- Game and UI setup ---
        // Load external libraries (required globally)
        const scriptChess = document.createElement('script');
        scriptChess.src = "https://unpkg.com/chess.js@1.0.0-beta.7/dist/chess.js";
        document.head.appendChild(scriptChess);
        
        const scriptBoard = document.createElement('script');
        scriptBoard.src = "https://unpkg.com/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js";
        document.head.appendChild(scriptBoard);

        // Wait for both scripts to load before initializing the game
        let scriptsLoaded = 0;
        const initGame = () => {
            scriptsLoaded++;
            if (scriptsLoaded === 2) {
                // Initialize game only after scripts are loaded AND auth is ready (handled in onAuthStateChanged)
                if (isAuthReady) {
                    window.game = new Chess();
                    window.board = ChessBoard('board', {
                        draggable: true,
                        position: 'start',
                        onDrop: onDrop,
                        onSnapEnd: onSnapEnd
                    });
                    updateStatus();
                    setupEventListeners();
                }
            }
        };
        scriptChess.onload = initGame;
        scriptBoard.onload = initGame;

        // --- CONSTANTS AND HELPERS ---
        // !!! IMPORTANT: CHANGE THIS URL TO YOUR DEPLOYED VERCEL FUNCTION URL !!!
        const PROXY_URL = 'https://komu-labs.vercel.app/api/gemini-move'; 
        const GEMINI_MODEL = "gemini-2.5-flash-preview-09-2025";
        const API_KEY = ""; // Not used here, key is on the backend proxy server

        const STATUS_ELEM = document.getElementById('status');
        const FEN_ELEM = document.getElementById('fen-display');
        const LOADING_ELEM = document.getElementById('loading-indicator');
        
        const MAX_RETRIES = 5;

        // --- FIREBASE FUNCTIONS ---
        const getGameStateDocRef = (uid) => {
            if (!db || !uid) return null;
            // Private data storage path: /artifacts/{appId}/users/{userId}/game_state/{docId}
            return doc(db, 'artifacts', appId, 'users', uid, 'game_state', 'current');
        };

        const saveGameState = async (fen) => {
            if (!isAuthReady || !userId) {
                console.warn("Authentication not ready. Cannot save state.");
                return;
            }
            const docRef = getGameStateDocRef(userId);
            if (!docRef) return;

            try {
                await setDoc(docRef, { fen: fen, timestamp: new Date() }, { merge: true });
                console.log("Game state saved successfully:", fen);
            } catch (e) {
                console.error("Error saving game state:", e);
            }
        };

        const loadGameState = async (uid) => {
            if (!isAuthReady || !uid || !window.game || !window.board) {
                // Wait for all components to initialize
                return;
            }
            
            const docRef = getGameStateDocRef(uid);
            if (!docRef) {
                window.board.start();
                return;
            }

            try {
                const docSnap = await getDoc(docRef);
                if (docSnap.exists()) {
                    const savedFen = docSnap.data().fen;
                    window.game.load(savedFen);
                    window.board.position(savedFen);
                    updateStatus();
                    console.log("Game state loaded successfully:", savedFen);
                } else {
                    window.board.start(); // Start new game if no save found
                    console.log("No saved game state found. Starting new game.");
                }
            } catch (e) {
                console.error("Error loading game state:", e);
                window.board.start(); // Start new game on error
            }
        };

        // --- CHESS LOGIC ---
        function updateStatus() {
            let status = '';
            const moveColor = (window.game.turn() === 'w') ? 'White (You)' : 'Black (Gemini)';

            if (window.game.isCheckmate()) {
                status = 'Game over, ' + moveColor + ' is in checkmate.';
            } else if (window.game.isDraw()) {
                status = 'Game over, drawn position.';
            } else {
                status = moveColor + ' to move.';
                if (window.game.isCheck()) {
                    status += ' ' + moveColor + ' is in check.';
                }
            }

            STATUS_ELEM.innerHTML = status;
            FEN_ELEM.textContent = 'FEN: ' + window.game.fen();
        }

        function onDrop(source, target) {
            // Check if the move is legal
            const move = window.game.move({
                from: source,
                to: target,
                promotion: 'q' // always promote to queen for simplicity
            });

            // Illegal move
            if (move === null) return 'snapback';
            
            updateStatus();
            saveGameState(window.game.fen());

            // If it's Black's turn after the move, request Gemini move
            if (window.game.turn() === 'b' && !window.game.isGameOver()) {
                window.setTimeout(makeGeminiMove, 250);
            }
        }

        // --- AI LOGIC ---

        // Function to handle exponential backoff for retries
        const fetchWithRetry = async (url, options, retries = 0) => {
            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response;
            } catch (error) {
                if (retries < MAX_RETRIES) {
                    const delay = Math.pow(2, retries) * 1000 + Math.random() * 1000;
                    console.warn(`Fetch failed. Retrying in ${Math.round(delay / 1000)}s... (Attempt ${retries + 1}/${MAX_RETRIES})`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return fetchWithRetry(url, options, retries + 1);
                }
                throw new Error(`Fetch failed after ${MAX_RETRIES} attempts: ${error.message}`);
            }
        };

        async function makeGeminiMove() {
            LOADING_ELEM.classList.remove('hidden');
            STATUS_ELEM.querySelector('span').textContent = "Black (Gemini) is thinking...";
            
            const fen = window.game.fen();

            const body = {
                fen: fen,
                model: GEMINI_MODEL,
                apiKey: API_KEY, // Sent for verification, but not used for API call on frontend
            };

            const options = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            };

            try {
                const response = await fetchWithRetry(PROXY_URL, options);
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }

                const geminiMove = data.move;
                
                // Apply the move
                const result = window.game.move(geminiMove, { sloppy: true });

                if (result) {
                    window.board.position(window.game.fen());
                    saveGameState(window.game.fen());
                } else {
                    console.error("Gemini returned an illegal move:", geminiMove);
                    // Handle illegal move by just updating the status, opponent gets another turn
                }

            } catch (error) {
                console.error("Error making Gemini move:", error);
                // Display error to the user
                STATUS_ELEM.querySelector('span').textContent = `Error: ${error.message}. Try undoing and making a different move.`;
            } finally {
                LOADING_ELEM.classList.add('hidden');
                updateStatus();
            }
        }


        // update the board position after a piece snap for castling, en passant, etc.
        function onSnapEnd() {
            window.board.position(window.game.fen());
        }

        // --- EVENT LISTENERS ---
        function setupEventListeners() {
            document.getElementById('reset-btn').addEventListener('click', () => {
                window.game.reset();
                window.board.start();
                updateStatus();
                saveGameState(window.game.fen());
                STATUS_ELEM.querySelector('span').textContent = 'Game reset. White to move.';
            });

            document.getElementById('undo-btn').addEventListener('click', () => {
                window.game.undo(); // Undo AI move
                window.game.undo(); // Undo Player move
                window.board.position(window.game.fen());
                updateStatus();
                saveGameState(window.game.fen());
            });
        }
    </script>
</body>
</html>